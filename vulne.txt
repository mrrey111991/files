CRIT
libssl3t64 3.0.13-0ubuntu3.5
libc6 2.39-0ubuntu8.5
locales 2.39-0ubuntu8.5
dpkg 1.22.6ubuntu6.1
openssl 3.0.13-0ubuntu3.5
libsqlite3-0 3.45.1-1ubuntu2.4
libc-bin 2.39-0ubuntu8.5
sqlite3 3.45.1-1ubuntu2.4


HIGH
libcurl4t64 8.5.0-2ubuntu10.6
libssl3t64 3.0.13-0ubuntu3.6
libc6 2.39-0ubuntu8.6
openssl 3.0.13-0ubuntu3.6
libpam-modules 1.5.3-5ubuntu5.5
libpam-modules-bin 1.5.3-5ubuntu5.5
curl 8.5.0-2ubuntu10.6
libc-bin 2.39-0ubuntu8.6
libpam-runtime 1.5.3-5ubuntu5.5
libexpat1 2.6.1-2ubuntu0.3
locales 2.39-0ubuntu8.6
libpam0g 1.5.3-5ubuntu5.5
expat 2.6.1-2ubuntu0.3


$, '(', ')', ',', '.', '=', COMPOSITE_OPERATOR, FLOATING_POINT_LITERAL, IDENTIFIER, INTEGER_LITERAL, OTHER_PUNCT, QUOTE, SIMPLE_OPERATOR, VERSION_LITERAL, '[', ']', '{' or '}' expected, got '}'



HIGH
libssl3t64 3.0.13-0ubuntu3.6 - CVE-2024-41996
libexpat1 2.6.1-2ubuntu0.3 - CVE-2025-59375
libpam-runtime 1.5.3-5ubuntu5.5 - CVE-2025-8941
libcurl4t64 8.5.0-2ubuntu10.6 - CVE-2025-9086
libpam0g 1.5.3-5ubuntu5.5 - CVE-2025-8941
libpam-modules 1.5.3-5ubuntu5.5 - CVE-2025-8941
locales 2.39-0ubuntu8.6 - CVE-2016-20013
curl 8.5.0-2ubuntu10.6 - CVE-2025-9086
libpam-modules-bin 1.5.3-5ubuntu5.5 - CVE-2025-8941
libc6 2.39-0ubuntu8.6 - CVE-2016-20013
openssl 3.0.13-0ubuntu3.6 - CVE-2024-41996
libc-bin 2.39-0ubuntu8.6 - CVE-2016-20013
expat 2.6.1-2ubuntu0.3 - CVE-2025-59375



curl:8.5.0-2ubuntu10.6 CVE-2025-9086, CVE-2025-10148, CVE-2025-0167
libcurl4t64 8.5.0-2ubuntu10.6 CVE-2025-9086, CVE-2025-10148, CVE-2025-0167
openssl 3.0.13-0ubuntu3.6 CVE-2024-41996, CVE-2025-27587
libssl3t64 3.0.13-0ubuntu3.6 CVE-2024-41996, CVE-2025-27587
libpam0g 1.5.3-5ubuntu5.5 CVE-2025-8941, CVE-2024-10041
libpam-modules-bin 1.5.3-5ubuntu5.5 CVE-2025-8941, CVE-2024-10041
libpam-modules 1.5.3-5ubuntu5.5 CVE-2025-8941, CVE-2024-10041
libpam-runtime:1.5.3-5ubuntu5.5 CVE-2025-8941, CVE-2024-10041
locales 2.39-0ubuntu8.6 CVE-2016-20013
libc6 2.39-0ubuntu8.6 CVE-2016-20013
libexpat1 2.6.1-2ubuntu0.3 CVE-2025-59375
libc-bin 2.39-0ubuntu8.6 CVE-2016-20013
expat 2.6.1-2ubuntu0.3 CVE-2025-59375


ubuntu:rolling
eclipse-temurin:latest

libpam-modules 1.5.3-5ubuntu5.5
libpam-modules-bin 1.5.3-5ubuntu5.5
libc-bin 2.39-0ubuntu8.6
libc6 2.39-0ubuntu8.6
libssl3t64 3.0.13-0ubuntu3.6
libpam-runtime 1.5.3-5ubuntu5.5
libexpat1 2.6.1-2ubuntu0.3
libpam0g 1.5.3-5ubuntu5.5
openssl 3.0.13-0ubuntu3.6
locales 2.39-0ubuntu8.6
expat 2.6.1-2ubuntu0.3




#!/bin/sh

basedir="/usr/local/tomcat/bin/database/"
txtfile="/usr/local/tomcat/bin/database/forDeployment.txt"

URL="${FIS_CYBERARK_URL}"
KEY1="${FIS_CYBERARK_APPID}"
KEY2="${FIS_CYBERARK_SAFE}"
KEY3="${FIS_CYBERARK_OBJ}"

DATA=$(cat <<EOF
{
 "appID": "$KEY1",
 "safe": "$KEY2",
 "objectName": "$KEY3"
}
EOF
)
Server="${FIS_DB_HOST}"
Database="${FIS_DB_NAME}"
if [ "${FIS_CYBERARK_ENABLE}" = false ]
then
  Username="${FIS_DB_USER}"
  Password=$(cat "${FIS_DB_PASS}")
else
  Username="${FIS_CYBERARK_USER}"
  CONTENT_TYPE_HEADER1="Accept: application/json"
  CONTENT_TYPE_HEADER2="Content-Type: application/json"
  response=$(curl -s -X POST -H "$CONTENT_TYPE_HEADER1" -H "$CONTENT_TYPE_HEADER2" -d "$DATA" "$URL")
  Password=$(echo "$response" | grep -o '"content":"[^"]*"' | sed -E 's/"content":"(.*)"/\1/')
  errorMessage=$(echo "$response" | grep -o '"errorMessage":"[^"]*"' | sed -E 's/"errorMessage":"(.*)"/\1/')
fi

echo $Username
echo $errorMessage
echo ""

if [ -s "$txtfile" ]; then
  for line in $(cat "$txtfile")
  do
    forDeployment=$(echo "$line" | sed ':a;N;$!ba;s/\n//g')
    echo "$forDeployment"
    if [ -d "$basedir$forDeployment" ]; then
      IsDeployed=$(sqlcmd -S $Server -d $Database -U $Username -P $Password -Q "
      EXEC DBO.DEPLOYMENT_CHECK '$forDeployment' ; " -h -1 -W)
      #echo "$IsDeployed"
      if [ "$IsDeployed" == "0" ] || [[ "$IsDeployed" == *"stored procedure"* ]]; then
        echo "Deploying script/s.... "
        for file in "$basedir$forDeployment"/*.sql; do
         if [[ -f "$file" ]]; then
            echo  ">>>>>>$file"
            sqlcmd -S $Server -d $Database -U $Username -P $Password -i "$file"
         fi
        done
        sqlcmd -S $Server -d $Database -U $Username -P $Password -Q "
            EXEC DBO.DEPLOYMENT_UPDATE '$forDeployment', true "
            echo "SQL script/s successfully deployed."
            echo ""
      else
          echo "This update was already deployed."
          echo ""
      fi
    else
      echo "SQL script Directory does not exists"
    fi
  done
else
  echo "No SQL script to deploy"
fi

rm -rf "$basedir"









#!/bin/bash
set -euo pipefail

basedir="/usr/local/tomcat/bin/database"
txtfile="${basedir}/forDeployment.txt"

URL="${FIS_CYBERARK_URL:-}"
KEY1="${FIS_CYBERARK_APPID:-}"
KEY2="${FIS_CYBERARK_SAFE:-}"
KEY3="${FIS_CYBERARK_OBJ:-}"

read -r -d '' DATA <<EOF || true
{
 "appID": "${KEY1}",
 "safe": "${KEY2}",
 "objectName": "${KEY3}"
}
EOF

Server="${FIS_DB_HOST:-}"
Database="${FIS_DB_NAME:-}"

if [[ "${FIS_CYBERARK_ENABLE:-false}" == "false" ]]; then
	
  Username="${FIS_DB_USER:-}"
  # If FIS_DB_PASS is a file path, read it; else treat literal value.
  if [[ -n "${FIS_DB_PASS:-}" && -f "${FIS_DB_PASS}" ]]; then
    Password="$(cat "${FIS_DB_PASS}")"
  else
    Password="${FIS_DB_PASS:-}"
  fi
else
  Username="${FIS_CYBERARK_USER:-}"
  CONTENT_TYPE_HEADER1="Accept: application/json"
  CONTENT_TYPE_HEADER2="Content-Type: application/json"
  response="$(curl -s -X POST -H "$CONTENT_TYPE_HEADER1" -H "$CONTENT_TYPE_HEADER2" -d "$DATA" "$URL")"
  # BusyBox-friendly sed (no -E). Extract fields if present.
  Password="$(echo "$response" | sed -n 's/.*"content":"\([^"]*\)".*/\1/p')"
  errorMessage="$(echo "$response" | sed -n 's/.*"errorMessage":"\([^"]*\)".*/\1/p' || true)"
fi

[[ -n "${Username:-}" ]] && echo "Username: $Username"
[[ -n "${errorMessage:-}" ]] && echo "CyberArk error: $errorMessage"
echo

if [[ ! -s "$txtfile" ]]; then
  echo "No SQL script to deploy"
  exit 0
fi

# Read targets line-by-line (preserves spaces)
while IFS= read -r forDeployment || [[ -n "$forDeployment" ]]; do
  # skip empty/comment lines
  [[ -z "$forDeployment" ]] && continue
  [[ "$forDeployment" =~ ^# ]] && continue

  echo "Target set: $forDeployment"
  dir="${basedir}/${forDeployment}"

  if [[ -d "$dir" ]]; then
    # Run check; don't fail the script if the query prints warnings
    IsDeployed="$(
      sqlcmd -S "$Server" -d "$Database" -U "$Username" -P "$Password" \
        -Q "EXEC DBO.DEPLOYMENT_CHECK '$forDeployment' ; " -h -1 -W 2>&1 || true
    )"

    needs_deploy="yes"
    # adjust logic if your proc returns different semantics
    if [[ "$IsDeployed" == "0" ]]; then
      needs_deploy="yes"
    elif [[ "$IsDeployed" == *"stored procedure"* ]]; then
      needs_deploy="yes"
    fi

    if [[ "$needs_deploy" == "yes" ]]; then
      echo "Deploying script(s)..."
      shopt -s nullglob
      files=( "$dir"/*.sql )
      if (( ${#files[@]} == 0 )); then
        echo "No .sql files found under $dir"
															   
													  
				   
      else
        for file in "${files[@]}"; do
          echo ">>>>>> $file"
          sqlcmd -S "$Server" -d "$Database" -U "$Username" -P "$Password" -i "$file"
        done
        sqlcmd -S "$Server" -d "$Database" -U "$Username" -P "$Password" \
          -Q "EXEC DBO.DEPLOYMENT_UPDATE '$forDeployment', true"
        echo "SQL script(s) successfully deployed."
      fi
      echo
      shopt -u nullglob
    else
      echo "This update was already deployed."
      echo
    fi
	  
  else
    echo "SQL script directory does not exist: $dir"
  fi
done < "$txtfile"

# Optional cleanup (keep if intentional)
rm -rf "$basedir"

