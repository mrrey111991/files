CRIT
libssl3t64 3.0.13-0ubuntu3.5
libc6 2.39-0ubuntu8.5
locales 2.39-0ubuntu8.5
dpkg 1.22.6ubuntu6.1
openssl 3.0.13-0ubuntu3.5
libsqlite3-0 3.45.1-1ubuntu2.4
libc-bin 2.39-0ubuntu8.5
sqlite3 3.45.1-1ubuntu2.4


HIGH
libcurl4t64 8.5.0-2ubuntu10.6
libssl3t64 3.0.13-0ubuntu3.6
libc6 2.39-0ubuntu8.6
openssl 3.0.13-0ubuntu3.6
libpam-modules 1.5.3-5ubuntu5.5
libpam-modules-bin 1.5.3-5ubuntu5.5
curl 8.5.0-2ubuntu10.6
libc-bin 2.39-0ubuntu8.6
libpam-runtime 1.5.3-5ubuntu5.5
libexpat1 2.6.1-2ubuntu0.3
locales 2.39-0ubuntu8.6
libpam0g 1.5.3-5ubuntu5.5
expat 2.6.1-2ubuntu0.3


$, '(', ')', ',', '.', '=', COMPOSITE_OPERATOR, FLOATING_POINT_LITERAL, IDENTIFIER, INTEGER_LITERAL, OTHER_PUNCT, QUOTE, SIMPLE_OPERATOR, VERSION_LITERAL, '[', ']', '{' or '}' expected, got '}'



HIGH
libssl3t64 3.0.13-0ubuntu3.6 - CVE-2024-41996
libexpat1 2.6.1-2ubuntu0.3 - CVE-2025-59375
libpam-runtime 1.5.3-5ubuntu5.5 - CVE-2025-8941
libcurl4t64 8.5.0-2ubuntu10.6 - CVE-2025-9086
libpam0g 1.5.3-5ubuntu5.5 - CVE-2025-8941
libpam-modules 1.5.3-5ubuntu5.5 - CVE-2025-8941
locales 2.39-0ubuntu8.6 - CVE-2016-20013
curl 8.5.0-2ubuntu10.6 - CVE-2025-9086
libpam-modules-bin 1.5.3-5ubuntu5.5 - CVE-2025-8941
libc6 2.39-0ubuntu8.6 - CVE-2016-20013
openssl 3.0.13-0ubuntu3.6 - CVE-2024-41996
libc-bin 2.39-0ubuntu8.6 - CVE-2016-20013
expat 2.6.1-2ubuntu0.3 - CVE-2025-59375



curl:8.5.0-2ubuntu10.6 CVE-2025-9086, CVE-2025-10148, CVE-2025-0167
libcurl4t64 8.5.0-2ubuntu10.6 CVE-2025-9086, CVE-2025-10148, CVE-2025-0167
openssl 3.0.13-0ubuntu3.6 CVE-2024-41996, CVE-2025-27587
libssl3t64 3.0.13-0ubuntu3.6 CVE-2024-41996, CVE-2025-27587
libpam0g 1.5.3-5ubuntu5.5 CVE-2025-8941, CVE-2024-10041
libpam-modules-bin 1.5.3-5ubuntu5.5 CVE-2025-8941, CVE-2024-10041
libpam-modules 1.5.3-5ubuntu5.5 CVE-2025-8941, CVE-2024-10041
libpam-runtime:1.5.3-5ubuntu5.5 CVE-2025-8941, CVE-2024-10041
locales 2.39-0ubuntu8.6 CVE-2016-20013
libc6 2.39-0ubuntu8.6 CVE-2016-20013
libexpat1 2.6.1-2ubuntu0.3 CVE-2025-59375
libc-bin 2.39-0ubuntu8.6 CVE-2016-20013
expat 2.6.1-2ubuntu0.3 CVE-2025-59375


ubuntu:rolling
eclipse-temurin:latest

libpam-modules 1.5.3-5ubuntu5.5
libpam-modules-bin 1.5.3-5ubuntu5.5
libc-bin 2.39-0ubuntu8.6
libc6 2.39-0ubuntu8.6
libssl3t64 3.0.13-0ubuntu3.6
libpam-runtime 1.5.3-5ubuntu5.5
libexpat1 2.6.1-2ubuntu0.3
libpam0g 1.5.3-5ubuntu5.5
openssl 3.0.13-0ubuntu3.6
locales 2.39-0ubuntu8.6
expat 2.6.1-2ubuntu0.3




#!/bin/sh

basedir="/usr/local/tomcat/bin/database/"
txtfile="/usr/local/tomcat/bin/database/forDeployment.txt"

URL="${FIS_CYBERARK_URL}"
KEY1="${FIS_CYBERARK_APPID}"
KEY2="${FIS_CYBERARK_SAFE}"
KEY3="${FIS_CYBERARK_OBJ}"

DATA=$(cat <<EOF
{
 "appID": "$KEY1",
 "safe": "$KEY2",
 "objectName": "$KEY3"
}
EOF
)
Server="${FIS_DB_HOST}"
Database="${FIS_DB_NAME}"
if [ "${FIS_CYBERARK_ENABLE}" = false ]
then
  Username="${FIS_DB_USER}"
  Password=$(cat "${FIS_DB_PASS}")
else
  Username="${FIS_CYBERARK_USER}"
  CONTENT_TYPE_HEADER1="Accept: application/json"
  CONTENT_TYPE_HEADER2="Content-Type: application/json"
  response=$(curl -s -X POST -H "$CONTENT_TYPE_HEADER1" -H "$CONTENT_TYPE_HEADER2" -d "$DATA" "$URL")
  Password=$(echo "$response" | grep -o '"content":"[^"]*"' | sed -E 's/"content":"(.*)"/\1/')
  errorMessage=$(echo "$response" | grep -o '"errorMessage":"[^"]*"' | sed -E 's/"errorMessage":"(.*)"/\1/')
fi

echo $Username
echo $errorMessage
echo ""

if [ -s "$txtfile" ]; then
  for line in $(cat "$txtfile")
  do
    forDeployment=$(echo "$line" | sed ':a;N;$!ba;s/\n//g')
    echo "$forDeployment"
    if [ -d "$basedir$forDeployment" ]; then
      IsDeployed=$(sqlcmd -S $Server -d $Database -U $Username -P $Password -Q "
      EXEC DBO.DEPLOYMENT_CHECK '$forDeployment' ; " -h -1 -W)
      #echo "$IsDeployed"
      if [ "$IsDeployed" == "0" ] || [[ "$IsDeployed" == *"stored procedure"* ]]; then
        echo "Deploying script/s.... "
        for file in "$basedir$forDeployment"/*.sql; do
         if [[ -f "$file" ]]; then
            echo  ">>>>>>$file"
            sqlcmd -S $Server -d $Database -U $Username -P $Password -i "$file"
         fi
        done
        sqlcmd -S $Server -d $Database -U $Username -P $Password -Q "
            EXEC DBO.DEPLOYMENT_UPDATE '$forDeployment', true "
            echo "SQL script/s successfully deployed."
            echo ""
      else
          echo "This update was already deployed."
          echo ""
      fi
    else
      echo "SQL script Directory does not exists"
    fi
  done
else
  echo "No SQL script to deploy"
fi

rm -rf "$basedir"









#!/bin/bash
# Deploy SQL scripts listed in forDeployment.txt using go-sqlcmd
# Works on Alpine (bash installed), BusyBox tools, and your /usr/local/tomcat layout.

set -euo pipefail

basedir="/usr/local/tomcat/bin/database"
txtfile="${basedir}/forDeployment.txt"

# ---- Env / inputs ----
URL="${FIS_CYBERARK_URL:-}"
KEY1="${FIS_CYBERARK_APPID:-}"
KEY2="${FIS_CYBERARK_SAFE:-}"
KEY3="${FIS_CYBERARK_OBJ:-}"

Server="${FIS_DB_HOST:-}"
Database="${FIS_DB_NAME:-}"
CyberarkEnable="${FIS_CYBERARK_ENABLE:-false}"

# Build JSON payload (no jq needed)
read -r -d '' DATA <<EOF || true
{
 "appID": "${KEY1}",
 "safe": "${KEY2}",
 "objectName": "${KEY3}"
}
EOF

# ---- Resolve credentials ----
if [[ "${CyberarkEnable}" == "false" ]]; then
  Username="${FIS_DB_USER:-}"
  # FIS_DB_PASS may be a file path or a literal
  if [[ -n "${FIS_DB_PASS:-}" && -f "${FIS_DB_PASS}" ]]; then
    Password="$(cat "${FIS_DB_PASS}")"
  else
    Password="${FIS_DB_PASS:-}"
  fi
else
  Username="${FIS_CYBERARK_USER:-}"
  CONTENT_TYPE_HEADER1="Accept: application/json"
  CONTENT_TYPE_HEADER2="Content-Type: application/json"
  response="$(curl -s -X POST -H "$CONTENT_TYPE_HEADER1" -H "$CONTENT_TYPE_HEADER2" -d "$DATA" "$URL")"
  # BusyBox-friendly sed (no -E)
  Password="$(echo "$response" | sed -n 's/.*"content":"\([^"]*\)".*/\1/p')"
  errorMessage="$(echo "$response" | sed -n 's/.*"errorMessage":"\([^"]*\)".*/\1/p' || true)"
fi

[[ -n "${Username:-}" ]] && echo "Username: $Username"
[[ -n "${errorMessage:-}" ]] && echo "CyberArk error: $errorMessage"
echo

# ---- Quick validations ----
if ! command -v sqlcmd >/dev/null 2>&1; then
  echo "ERROR: sqlcmd not found on PATH" >&2
  exit 1
fi
if [[ -z "${Server}" || -z "${Database}" || -z "${Username}" || -z "${Password}" ]]; then
  echo "ERROR: Missing DB connection variables (host/db/user/pass)." >&2
  exit 1
fi

# ---- Nothing to deploy? ----
if [[ ! -s "$txtfile" ]]; then
  echo "No SQL script to deploy"
  exit 0
fi

# Normalize CRLF and ensure trailing newline so the simple loop ends cleanly
sed -i -e 's/\r$//' -e '$a\' "$txtfile"

# ---- Process each target line-by-line ----
while IFS= read -r forDeployment; do
  # skip empty/comment lines
  [[ -z "$forDeployment" || "$forDeployment" =~ ^# ]] && continue

  echo "Target set: $forDeployment"
  dir="${basedir}/${forDeployment}"

  if [[ -d "$dir" ]]; then
    # Run check; do not fail the whole script if the query prints warnings
    IsDeployed="$(
      sqlcmd -S "$Server" -d "$Database" -U "$Username" -P "$Password" \
        -Q "EXEC DBO.DEPLOYMENT_CHECK '$forDeployment' ; " -h -1 -W 2>&1 || true
    )"

    # Decide if we need to deploy (adjust to your proc semantics)
    needs_deploy="no"
    [[ "$IsDeployed" == "0" ]] && needs_deploy="yes"
    [[ "$IsDeployed" == *"stored procedure"* ]] && needs_deploy="yes"

    if [[ "$needs_deploy" == "yes" ]]; then
      echo "Deploying script(s)..."
      shopt -s nullglob
      found_any="no"
      for file in "$dir"/*.sql; do
        [[ -f "$file" ]] || continue
        found_any="yes"
        echo ">>>>>> $file"
        sqlcmd -S "$Server" -d "$Database" -U "$Username" -P "$Password" -i "$file"
      done
      shopt -u nullglob

      if [[ "$found_any" == "yes" ]]; then
        sqlcmd -S "$Server" -d "$Database" -U "$Username" -P "$Password" \
          -Q "EXEC DBO.DEPLOYMENT_UPDATE '$forDeployment', true"
        echo "SQL script(s) successfully deployed."
      else
        echo "No .sql files found under $dir"
      fi
      echo
    else
      echo "This update was already deployed."
      echo
    fi
  else
    echo "SQL script directory does not exist: $dir"
  fi
done < "$txtfile"

# ---- Optional cleanup (keep if intended) ----
rm -rf "$basedir"




